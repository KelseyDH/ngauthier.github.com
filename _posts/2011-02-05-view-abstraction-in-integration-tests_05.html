---
layout: post
title: View Abstraction in Integration Tests
date: 2011-02-05
comments: false
---
<div class='post'>
<h5>Goal: Make integration tests drier by adding a view abstraction layer</h5><p>Ruby on Rails has a bunch of popular of test frameworks, such as:</p><ul><li>RSpec</li><li>Cucumber</li><li>Test::Unit</li><li>Steak</li></ul><p>But one common aspect to all of the frameworks, out of the box, is that they're very procedural. Cucumber is designed so that each scenario has a set of steps. There is a single, global, collection of steps. RSpec is global by nature, there are no test classes, just describe blocks.</p><p>There is no doubt in my mind that these frameworks have made testing easier by adding lots of common actions, and allowing you to define your own common actions.</p><p>However, there is one thing that I don't see much of in tests: <b>Object-Oriented Patterns</b>. Most of us use the Factory pattern through a variety of gems. Internally, many frameworks use the Visitor pattern to execute the tests. But that's all I've ever seen (disclaimer: I am young, and have much to learn).</p><p>Here are some pain points I've felt while writing integration tests in the past:</p><ul><li>Hard to reference objects throughout Cucumber scenarios. Often resulting in global variables used between steps</li><li>Cumbersome to check the view for expected output, often resulting in lots of css selectors</li><li>Brittleness introduced by coding html and css structure into test code that prevents refactoring the view</li></ul><p>So, I recently had to write some integration tests from scratch, and I decided to do something different. I decided to implement the <a href="http://en.wikipedia.org/wiki/Bridge_pattern">Bridge Pattern</a> in my integration tests. I was confident enough in the solution that I decided to just use Test::Unit and Capybara to write my test code.</p><p>One of the major goals of this implementation is to <b>make it easy to interact with the UI and objects within it</b>. I think it's time I show some code.</p><h5>Post Test for a simple blog site</h5><pre class="prettyprint"># Given I am on the posts page<br />visit posts_path<br /># When I create a new post<br />click_link 'New Post'<br />View::Post.create(<br />  :title => 'View abstraction in integration tests',<br />  :body => 'We must go deeper'<br />)<br /># Then I should see a success message<br />assert_see 'Successfully created post.'<br /># When I visit the posts index<br />visit posts_path<br /># Then I should see one post<br />assert_equal 1, View::Post.all.size<br /># And it should have the correct title<br />assert_equal 'View abstraction in integration tests',<br />             View::Post.all.first.title<br /># And it should have the correct body<br />assert_equal 'We must go deeper', View::Post.all.first.body<br /></pre><p>Let's take a look at a few interesting things:</p><ul><li>I'm directly using Capybara's dsl to navigate</li><li>When I create a post, I'm using a View module so that it won't use the ActiveRecord object</li><li>When I create a post, I pass in a hash of the fields I'd like to fill in</li><li>When I check to see if the post is created, I'm using methods on View::Post that return ruby objects, like an array, and that instances of View::Post have methods like "title" and "body"</li><li>There are no css selectors or html, but I do have button test present</li></ul><p>OK, hopefully that piqued your interest. Let's look at some of the implementation. First, let's check out the base View module and a barebones implementation of View::Post:</p><pre class="prettyprint">module View<br />  def self.body<br />    Nokogiri::HTML(Capybara.current_session.body)<br />  end<br /><br />  class Abstract<br />    # Access capybara dsl in the view helper classes too<br />    include Capybara<br />    extend  Capybara<br /><br />    def initialize(node)<br />      @id = node['id']<br />    end<br />    def self.all<br />      nodes.map{|node| new(node) }<br />    end<br />    private<br />    def id<br />      %{##{@id}}<br />    end<br />  end<br />  class Post < View::Abstract<br />    attr_reader :title<br />    attr_reader :body<br />    def initialize(node)<br />      super<br />      @title = node.css('.title').first.text.strip<br />      @body = node.css('.body').first.text.strip<br />    end<br /><br />    private<br />    def self.nodes<br />      View.body.css('.post')<br />    end<br />  end<br />end<br /></pre><p>OK what's going on here? Let me step you through it:</p><ul><li>When I call View::Post.all, that calls View::Abstract.all, which iterates over View::Post.nodes and builds instances of View::Post</li><li>View::Post.nodes runs Capybara's current page through Nokogiri, then selects all the HTML nodes with the class "post"</li><li>When a View::Post is initialized, it uses Nokogiri to set attributes on itself, from the view. Like title and body</li><li>View::Abstract always stores an object's dom id as @id so that it can be used internally, which we'll see next.</li></ul><p>Now lets take a look at how View::Post.create works:</p><pre class="prettyprint">module View<br />  class Post<br />    def self.create(opts = Hash.new(''))<br />      fill_form opts<br />      click_button 'Create Post'<br />    end<br />    def self.fill_form(opts)<br />      fill_in 'Title', :with => opts[:title]<br />      fill_in 'Body', :with => opts[:body]<br />    end<br />  end<br />end<br /></pre><p>Here we show how the class method uses capybara to take care of filling in the form for us. Now, if we change how our forms are rendered, we can change them in one place. Nice and DRY.</p><p>Let's look at one of the biggest pain points for me in cucumber: deleting an object in a list of objects. Why is this a pain point? I usually have to write a custom step like "When I delete the Post 'My Post'", which will use dom_id to find the id of a Post object found in the DB with the title "My Post". I find this really roundabout, because you don't need to look in the database for an object to figure out its dom id. It's right there in the view. Any competent internet user would be able to click on the "Delete" button for the post called "My Post" if you showed them the page in a browser. Here is the test code:</p><pre class="prettyprint"># Given I made two blog posts<br />2.times do |i|<br />  visit posts_path<br />  click_link 'New Post'<br />  View::Post.create(<br />    :title => "Post #{i}",<br />    :body => "Body for #{i}"<br />  )<br />end<br /># When I go to the posts path<br />visit posts_path<br /># Then I should see two posts<br />assert_equal 2, View::Post.all.size<br /># When I delete Post 0<br />View::Post.find_by_title('Post 0').delete<br /># Then I should see one post<br />assert_equal 1, View::Post.all.size<br /># And I should not see Post 0<br />assert_nil View::Post.find_by_title('Post 0')<br /># And I should see Post 1<br />refute_nil View::Post.find_by_title('Post 1')<br /></pre><p>Notice specifically the line where the post is deleted. I grabbed the instance of View::Post corresponding to the title I wanted and called .delete on it. Then I thoroughly check that the correct post was removed. Here is the implementation:</p><pre class="prettyprint">module View<br />  class Post<br />    def delete<br />      within(id) { click_button 'Delete' }<br />    end<br />  end<br />end<br /></pre><p>Expecting more? In View::Abstract we defined the method "id" which returns the dom id of the object which was stored when we initialized it. I simply told capybara to click "Delete" inside that node's div. This was the "eureka moment" for me. Something that is frustrating and difficult in other styles of testing is just plain simple with this pattern.</p><p>There is a <i>lot</i> more than can be done here, and I'm just scratching the surface. If you'd like to try it out for yourself, I've created a Rails project with this environment setup on github: <a href="https://github.com/ngauthier/view-abstraction-demo">View Abstraction Demo</a>. Here's how to use it:</p><pre class="prettyprint">git clone git://github.com/ngauthier/view-abstraction-demo.git<br />cd view-abstraction-demo<br />bundle<br />rake<br /></pre><p>Note: you must use ruby 1.9.2. Important files to look at are "test/test_helper.rb" and "test/integration/post_test.rb".</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Jakub</div>
<div class='content'>
I am sure your idea is gonna turn into a gem. It just fits so well in a view testing pattern and adds performance to it also. I don&#39;t fancy Cucumber, use Steak, but still I Repeat Myself with # and . so unql.<br /><br />Gem would be nice. Generating test/views/abstract.rb and test/views/abstract/model.rb - so nice to modify you know. I&#39;m looking forward to help out with gem development. Wish you luck.</div>
</div>
<div class='comment'>
<div class='author'>Nick Gauthier</div>
<div class='content'>
Hey Jakub, glad you liked the post.<br /><br />I don&#39;t think this would make a good gem, because only about 20 lines would be packaged. The generator would create very bare files because it would have no understanding of your css structure.<br /><br />Also, I&#39;ve found that UI elements don&#39;t always map 1:1 with database elements.<br /><br />Lastly, I find that the power of this pattern is simple and can be included directly in your code. Putting it in a gem would make it hard to change it on a project-by-project basis. I expect to add more helpful methods to abstract as I use this more.<br /><br />Thanks,<br />Nick</div>
</div>
<div class='comment'>
<div class='author'>Jakub</div>
<div class='content'>
Thanks for the answer Nick! You can be right, maybe it&#39;s too much for a gem, however having that in a generator could be a trick. <br /><br />There is no need for the gem to understand css nor thoughtlessly map db - it can generate some conventional files that can be easily modified to fit the view. Actually, modifying those files would be a first step of a view specification!<br /><br />The thing about that pattern is, for me, that those methods should not be stuffed in helpers (or additional spec/test methods) which is usually done. And to not forget that, the gem hooked to a initializer would be nice.</div>
</div>
<div class='comment'>
<div class='author'>Nick Gauthier</div>
<div class='content'>
yeah, I think moving them to separate files is definitely a cleaner way of doing it. Feel free to make a gem / plugin with generators to make it easier for yourself.</div>
</div>
<div class='comment'>
<div class='author'>Corey Haines</div>
<div class='content'>
Hi, Nick,<br />Good thoughts.<br />This looks similar to the page object pattern that a lot of people are using these days in Watir and Selenium tests. Have you looked at that? It could help influence your stuff, hopefully guide you past any dark corners they&#39;ve already dealt with.</div>
</div>
<div class='comment'>
<div class='author'>Nick Gauthier</div>
<div class='content'>
Thanks Corey, that&#39;s exactly what I&#39;m trying to do. I figured there was no way I could be the first person to think of this :-)</div>
</div>
<div class='comment'>
<div class='author'>Nick Gauthier</div>
<div class='content'>
@Jakub<br /><br />I&#39;ve been adding more functionality, and it seems like you&#39;re right and it would make a nice gem. Mostly to make it easier to define selectors and attributes, and make a bunch of convenience methods (like the enumerable methods).<br /><br />Also, I am planning on bundling some assertions with the gem, which will take advantage of capybara&#39;s automatic delay on failed assertions. I&#39;ll post on this blog soon when it is released.<br /><br />-Nick</div>
</div>
<div class='comment'>
<div class='author'>Nick Gauthier</div>
<div class='content'>
This has been released as a Gem, and the syntax is changed a bit:<br /><br />https://github.com/ngauthier/domino</div>
</div>
</div>
