---
layout: post
title: RESTful Many to Many Relationships in Rails
date: 2010-11-04
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<pre>GET    /people => List people<br />POST   /people => Create person<br />PUT    /people => Replace the collection<br />DELETE /people => Delete the collection<br /><br />GET    /people/:id => List attribute of a person<br />PUT    /people/:id => update the attributes of a person<br />POST   /people/:id => create a new collection under a person<br />DELETE /people/:id => Delete a person<br /></pre><br />In rails, we use<br /><br /><pre>index:   GET    /people     => List people<br />create:  POST   /people     => Create person<br />show:    GET    /people/:id => List attribute of a person<br />update:  PUT    /people/:id => update the attributes of a person<br />destroy: DELETE /people/:id => Delete a person<br /></pre><br />Now we may also have:<br /><br /><pre>index:   GET    /groups     => List groups<br />create:  POST   /groups     => Create group<br />show:    GET    /groups/:id => List attribute of a group<br />update:  PUT    /groups/:id => update the attributes of a group<br />destroy: DELETE /groups/:id => Delete a group<br /></pre><br />Consider a relationship of Many To Many between users and groups.<br /><br />How do I express the following?<br /><br />"Add user X to group Y"<br /><br />First thought may be:<br /><br /><pre>POST /groups/Y/users?user_id=X<br /></pre><br />But technically, this means "Create a user whose attributes are {user_id => X} under group Y". This is wrong in two ways, the first is that we don't want to create a user inside a group. The second is that the user attributes are wrong, it's {id => X}.<br /><br />The correct request would be:<br /><br /><pre>POST /groups_users?user_id=X&group_id=Y<br /></pre><br />This means "Create a new GroupUser linking node whose attributes are {user_id => X, group_id => Y}".<br /><br /><br />OK now how do I express the following?<br /><br />"Put user X into a new group, whose attributes are {name => 'My Group'}"<br /><br />This is *two* requests:<br /><br /><pre>POST /groups?name="My Group" => returns ID Z<br />POST /groups_users?user_id=X&group_id=Z<br /></pre><br />However, we can actually combine the requests like this:<br /><br /><pre>POST /users/X/groups?name="My Group"<br /></pre><br />In a situation where a Group Belongs To a User, this would create a group under the user.<br /><br />You would get in trouble if Group Belongs To a User and Group Has and Belongs To Many Users. However, in that case, you should be using another name for one of the assets. For example, Group could belong to a Creator, and a User would have a created_groups association. So the routes would actually be different:<br /><br /><pre>POST /users/X/created_groups?name="My Group"<br /></pre><br />Which would mean create a group, where User X is the creator of that group.<br /><br /><br />So, how do we handle this with Rails routing and controllers?<br /><br /><pre class="prettyprint">resources :groups do<br />  resources :users, :controller => 'GroupsUser', :only => [:index, :create, :destroy]<br />end<br />resources :users do<br />  resources :groups, :controller => 'UserGroups', :only => [:index, :create, :destroy]<br />end<br /></pre><br />Now, for user and group resources, we would use a traditional controller. For the GroupsUser and UserGroups controller, it would be a bit different.<br /><br />UserGroups controller:<br /><br />index: return all the groups this user is in<br />create: create a new group, and add this user to that group<br />destroy: remove this group from the user's list of groups<br /><br />Note we don't have:<br /><br />show: this is redundant with groups/show.<br />update: this would update the attributes on a membership. If it's just a join there are no attributes, however this may be useful if the join has attributes (for example, role)<br /><br /><br />The most interesting action here is create:<br /><br /><pre class="prettyprint">@user = User.find(params[:id])<br />@group = Group.new(params[:group])<br />Group.transaction do<br />  if @group.save<br />    if GroupUser.create(params[:group_user].merge{:user => @user, :group => @group})<br />      # success<br />    else<br />      # Could not add user to group<br />    end<br />  else<br />    # Could not create group<br />  end<br />end<br /></pre><br />Note that this controller is getting a bit dangerous because there are three logic paths. Generally, controllers will only have two logic paths: success and failure.<br /><br />Note also that we are merging the params[:group_user] when creating it. This is because we may want to have attributes on the GroupUser. This would all have to be in the form for posting to this action.<br /><br /><br />Technically, we are creating a group under a user. While this makes perfect sense in a belongs_to relationship, it is a little mind-bending in a many-to-many situation where the relationship is reciprocal. So, I'll end with a question. Do you think that this "double action" is a violation of REST?</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Nick Gauthier</div>
<div class='content'>
You also get the honor of the first reply!<br /><br />While that is convenient, it is not RESTful. The route you described is designed to modify the user resource, not any groups resources.<br /><br />Also, you&#39;re going to go through &quot;error hell&quot; if a bunch of those groups and user attributes are invalid.<br /><br />Doing nested attributes through a controller is trying to squeeze two entire controllers into one. For the sake of simplicity, testing, and maintainability, I&#39;d avoid it.<br /><br />-Nick</div>
</div>
<div class='comment'>
<div class='author'>pjb3</div>
<div class='content'>
First of all, let me say that I am honored to be the first commenter on ngauthier.com :)<br /><br />Second, what I would do is push the logic of creating a group down into the controller.  The nested attributes feature of Rails gives you this automatically.  Assuming your User model looks like this:<br /><br />    class User &lt; ActiveRecord::Base<br />      has_many :group_users<br />      has_many :groups, :through =&gt; :group_users<br />  <br />      accepts_nested_attributes_for :groups<br />    end<br /><br />Then the controller goes back to having just two paths, because user.save will take care of creating the group before creating the group_user.  So when you do:<br /><br />    PUT /users/X/?group_attributes[][name]=&quot;My Group&quot;<br /><br />this would happen:<br /><br />    user.update_attributes :groups_attributes =&gt; [{:name =&gt; &quot;My Group&quot;}]<br />      # =&gt; INSERT INTO &quot;groups&quot; (&quot;name&quot;) VALUES (&#39;My Group&#39;)<br />      # =&gt; INSERT INTO &quot;group_memberships&quot; (&quot;group_id&quot;, &quot;user_id&quot;) VALUES (1, 1)</div>
</div>
</div>
