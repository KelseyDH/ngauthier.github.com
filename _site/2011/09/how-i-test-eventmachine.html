<h1>How I test EventMachine</h1>
<div class='post'>
<p>EventMachine's asynchronous and evented nature can be pretty tough to test. Here are some simple Test::Unit helpers I use along with a sample example:</p><pre class='prettyprint'>def eventmachine(timeout = 1)<br />    Timeout::timeout(timeout) do<br />      EM.run do<br />        EM.epoll<br />        yield<br />      end<br />    end<br />  rescue Timeout::Error<br />    flunk 'Eventmachine was not stopped before the timeout expired'<br />  end<br /></pre><p>This is a helper that runs eventmachine in a timeout so that if it hangs the test suite flunks out after a second. Very handy.</p><pre class='prettyprint'>def set_em_steps(*steps)<br />    @@_em_steps = *steps<br />  end<br /><br />  def em_step_complete(step)<br />    @@_em_steps.delete(step)<br />    EM.stop if @@_em_steps.empty?<br />  end<br /></pre><p>This is a flow-control helper to make sure I complete all the steps I expected. Sometimes you run two chunks of EM code and then make assertions in the callbacks. Generally, you call EM.stop in your last callback, but what if they don't chain one after another? Then you have to call stop after both have finished. These two helpers just make it so that I can define my steps, then mark each as completed. They stop EM once all the steps are completed.</p><h3>Example</h3><p>Here is an example test from Shortmail.com's test suite for iPhone push notifications:</p><pre class='prettyprint'>test 'send a push notification to the push daemon' do<br />  token = Factory.next :iphone_device_token<br />  message = 'hello world'<br />  # define two steps that must be completed before stopping<br />  set_em_steps :payload, :notification<br /><br />  # run the following code, but time out after 1 second<br />  eventmachine do<br />    # MockServer is a fake iphone push server (pretending to be apple) <br />    # it yields responses back to the instantiator<br />    Test::Helpers::PushD::MockServer.listen do |response|<br />      # Unpack the push<br />      id, exp, device, payload = PushD::Pusher.unpack(response)<br /><br />      # make sure that the payload has the right into in it<br />      assert_equal token, device<br />      assert_equal message, JSON.parse(payload)['aps']['alert']<br /><br />      # mark the payload step as complete, meaning we've received<br />      # and verified it<br />      em_step_complete :payload<br />    end<br />    PushD::WebServer.listen<br /><br />    # This is another part of code under test.<br />    # This is how we send a push message<br />    PushNotifier.notify(token, :message => message) do |success|<br />      # When the push message is sent it runs the callback block with<br />      # a boolean and we ensure it's ok<br />      assert success<br />      # now make sure that this step is marked as finished<br />      em_step_complete :notification<br />    end<br />  end<br />end<br /></pre><p>Now, we can be sure our assertions are run, or it will time out because it won't stop.</p><p>How do you test eventmachine?</p></div>
<h2>Comments</h2>
<div class='comments'>
</div>
